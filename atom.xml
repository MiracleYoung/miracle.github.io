<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Miracle Blog</title>
  
  <subtitle>One tech boy blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-10-25T22:02:38.546Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Miracle.Young</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>k8s-3-初始化k8s集群</title>
    <link href="http://yoursite.com/%E6%8A%80%E6%9C%AF/k8s-3-%E5%88%9D%E5%A7%8B%E5%8C%96k8s%E9%9B%86%E7%BE%A4/"/>
    <id>http://yoursite.com/技术/k8s-3-初始化k8s集群/</id>
    <published>2018-10-25T22:01:33.000Z</published>
    <updated>2018-10-25T22:02:38.546Z</updated>
    
    <content type="html"><![CDATA[<p>k8s-3-初始化k8s集群<br>￼<br>￼<img src="https://ws4.sinaimg.cn/large/006tNbRwgy1fwl7bytqsnj30sy0ma426.jpg" alt=""><br><a id="more"></a></p><ul><li>手动安装，部署在系统之上<br><img src="https://ws1.sinaimg.cn/large/006tNbRwgy1fwl7c4fe6qj30rs0eigo1.jpg" alt=""></li><li>kubeadm：把k8s自己也部署成容器<ul><li>kubelet：运行pod的基础组件</li><li>docker：运行docker</li></ul></li><li>master上运行：API Server、etcd、controller-manager、scheduler，都运行为Pod的方式</li><li>各组件都需要flannel</li><li>master，nodes：安装kubelet，kubeadm，docker</li><li>master：kubeadm initi</li><li><p>nodes：kubeadm join</p></li><li><p>kubelet, kubeadm, kuernetes 安装</p><ul><li>yum-config-manager –add-repo <a href="https://download.docker.com/linux/centos/docker-ce.repo" target="_blank" rel="noopener">https://download.docker.com/linux/centos/docker-ce.repo</a></li><li><p>wget -P /etc/yum.repos.d/ <a href="https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg" target="_blank" rel="noopener">https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg</a> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@centos7-1 yum.repos.d]# cat kubernetes.repo</span><br><span class="line">[kubernetes]</span><br><span class="line">name=Kunernetes Repo</span><br><span class="line">baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg</span><br><span class="line">enabled=1</span><br></pre></td></tr></table></figure></li><li><p>wget <a href="https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg" target="_blank" rel="noopener">https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg</a></p></li><li>yum install kubelet kubeadm kubectl</li></ul></li><li>vim /usr/lib/systemd/system/docker.service<ul><li>Environment=”HTTPS_PROXY=<a href="http://www.ik8s.io:10080”" target="_blank" rel="noopener">http://www.ik8s.io:10080”</a></li><li>Environment=“NO_PROXY=127.0.0.0/8,172.17.0.0/16”</li></ul></li><li>systemctl daemon-reload</li><li>systemctl restart docker </li><li>cat /proc/sys/net/bridge/bridge-nf-call-ip6tables 确认是1</li><li><p>cat /proc/sys/net/bridge/bridge-nf-call-iptables 确认是1</p></li><li><p>初始化k8s：kubeadm init –pod-network-cidr=10.244.0.0/16 –service-cidr=10.96.0.0/12 –ignore-preflight-errors=Swap</p></li><li>run cmd：<ul><li>mkdir -p $HOME/.kube</li><li>sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</li><li>sudo chown $(id -u):$(id -g) $HOME/.kube/config</li></ul></li><li>加入其他节点，join nodes<ul><li>kubeadm join 172.16.163.129:6443 –token qzkzzn.kcros8j24l7adsi5 –discovery-token-ca-cert-hash sha256:84de83f916b04644f38f893246b9daf064967871ae3114726df2ea8fad63e7d8 –ignore-preflight-errors=Swap</li></ul></li><li><p>修改配置文件：/etc/sysconfig/kubelet</p><ul><li>KUBELET_EXTRA_ARGS=”–fail-swap-on=false”</li></ul></li><li><p>kubectl get cs</p></li><li>kubectl get nodes</li></ul><ul><li><p>部署flannel</p><ul><li>kubectl apply -f <a href="https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml" target="_blank" rel="noopener">https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml</a></li><li>通过kubectl get pods -n kube-system 查看pod 情况</li><li>kubectl get ns，查看kube的命名空间，一共有3个，default，kube-public，kube-system</li></ul></li><li><p>从节点部署，只需要kubeadm, kubelet, docker-ce</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;k8s-3-初始化k8s集群&lt;br&gt;￼&lt;br&gt;￼&lt;img src=&quot;https://ws4.sinaimg.cn/large/006tNbRwgy1fwl7bytqsnj30sy0ma426.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="k8s" scheme="http://yoursite.com/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>k8s-2-基础概念</title>
    <link href="http://yoursite.com/%E6%8A%80%E6%9C%AF/k8s-2-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    <id>http://yoursite.com/技术/k8s-2-基础概念/</id>
    <published>2018-10-25T21:58:41.000Z</published>
    <updated>2018-10-25T22:01:13.718Z</updated>
    
    <content type="html"><![CDATA[<p>k8s-2-基础概念</p><ul><li>master/node<ul><li>master：API Server，Scheduler，Controller-Manager</li><li>node：kubelet，docker，…</li></ul></li><li>Pod，Label，Label Selector<ul><li>Label：key=value</li><li>Label Selector：</li></ul></li><li>Pod：<ul><li>自主式Pod</li><li>控制器管理的Pod<ul><li>有生命周期的调度对象<ul><li>ReplicationController</li><li>ReplicaSet</li><li>Deployment</li><li>StatefulSet</li><li>DaemonSet</li><li>Job，Cronjob</li><li>HPA，HorizontalPodAutoscaler</li></ul></li></ul></li></ul></li><li>Services：<ul><li>AddOns：附件</li></ul></li></ul><a id="more"></a><p><img src="https://ws3.sinaimg.cn/large/006tNbRwgy1fwl791i7hzj30nm0eo75f.jpg" alt=""></p><ul><li>CNI<ul><li>flannel：网络配置</li><li>calico：网络配置，网络配置</li><li>canel：calico提供网络策略，flannel提供网络</li></ul></li></ul><p><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fwl7933zk4j31060guwhl.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;k8s-2-基础概念&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;master/node&lt;ul&gt;
&lt;li&gt;master：API Server，Scheduler，Controller-Manager&lt;/li&gt;
&lt;li&gt;node：kubelet，docker，…&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Pod，Label，Label Selector&lt;ul&gt;
&lt;li&gt;Label：key=value&lt;/li&gt;
&lt;li&gt;Label Selector：&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Pod：&lt;ul&gt;
&lt;li&gt;自主式Pod&lt;/li&gt;
&lt;li&gt;控制器管理的Pod&lt;ul&gt;
&lt;li&gt;有生命周期的调度对象&lt;ul&gt;
&lt;li&gt;ReplicationController&lt;/li&gt;
&lt;li&gt;ReplicaSet&lt;/li&gt;
&lt;li&gt;Deployment&lt;/li&gt;
&lt;li&gt;StatefulSet&lt;/li&gt;
&lt;li&gt;DaemonSet&lt;/li&gt;
&lt;li&gt;Job，Cronjob&lt;/li&gt;
&lt;li&gt;HPA，HorizontalPodAutoscaler&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Services：&lt;ul&gt;
&lt;li&gt;AddOns：附件&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="k8s" scheme="http://yoursite.com/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>k8s-1-架构基础</title>
    <link href="http://yoursite.com/%E6%8A%80%E6%9C%AF/k8s-1-%E6%9E%B6%E6%9E%84%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/技术/k8s-1-架构基础/</id>
    <published>2018-10-25T21:56:13.000Z</published>
    <updated>2018-10-25T21:58:19.331Z</updated>
    
    <content type="html"><![CDATA[<p>k8s-1-架构概述<br>￼<br><img src="https://ws1.sinaimg.cn/large/006tNbRwgy1fwl77kow4gj31aa0ua470.jpg" alt=""><br><a id="more"></a></p><ul><li>根据容器最低需求来调度决定使用哪个Node节点</li><li>k8s 二级调度<ul><li>先做预估筛选：哪些节点符合</li><li>优选：取决于优选算法</li></ul></li><li>API Server</li><li>Scheduler</li><li>Controller：监控容器是否健康，需要在master本地周期性探测</li><li>Controller Manager：监控每一个控制器的健康<ul><li>为了Controller Manager 健康，可以做冗余</li></ul></li></ul><p>￼<img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fwl77lpl7lj311i0p4tej.jpg" alt=""></p><ul><li>通过标签选择器（selector），根据过滤选择条件的选择器</li><li>master/node<ul><li>master：API Server，Scheduler，Controller-Manager</li><li>node：kebulet（集群代理，执行master分发的任务）</li></ul></li><li>Pod，调度原子单元</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;k8s-1-架构概述&lt;br&gt;￼&lt;br&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/006tNbRwgy1fwl77kow4gj31aa0ua470.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="k8s" scheme="http://yoursite.com/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>Dockerfile</title>
    <link href="http://yoursite.com/%E6%8A%80%E6%9C%AF/Dockerfile/"/>
    <id>http://yoursite.com/技术/Dockerfile/</id>
    <published>2018-10-17T15:13:53.000Z</published>
    <updated>2018-10-25T22:03:08.359Z</updated>
    
    <content type="html"><![CDATA[<p>今天继续输出Docker，等全部看完后，整理成系列。</p><p>为了解决自制镜像问题</p><ul><li>预定义模版，通过设置不同的变量<br><img src="https://ws4.sinaimg.cn/large/006tNbRwgy1fwbmml2vqlj30su0b8q4k.jpg" alt=""><br>￼<a id="more"></a></li></ul><h2 id="Dockerfile-Format"><a href="#Dockerfile-Format" class="headerlink" title="Dockerfile Format"></a>Dockerfile Format</h2><ul><li><h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1></li><li>指令 参数<ul><li>指令本身不区分大小写</li><li>约定俗成，使用大写</li></ul></li><li>第一个指令前必须指定FROM</li></ul><h2 id="Dockerfile-工作流程"><a href="#Dockerfile-工作流程" class="headerlink" title="Dockerfile 工作流程"></a>Dockerfile 工作流程</h2><ul><li>专用目录存放Dockerfile</li><li>Dockerfile文件名首字母必须大写</li><li>Dockerfile中引入的文件必须在工作目录下</li><li>使用.dockerignore，引入不需要被打包的东西</li><li>制作的镜像必须是底层镜像能够提供给我们的环境</li></ul><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><ul><li>引用：$variable_name, ${variable_name}</li><li>${variable:-word}：给variable设置默认值</li><li>${variable:+word}：若variable有值则为空字符串，否则是word</li></ul><h2 id="Dockerfile-Instructions"><a href="#Dockerfile-Instructions" class="headerlink" title="Dockerfile Instructions"></a>Dockerfile Instructions</h2><ul><li>FROM指令是最重的一个，且必须为Dockerfile文件开篇的第一个非注视行，用于为镜像文件构建过程指定基准镜像</li><li>语法：<ul><li>FROM <repository>[:<tag>] </tag></repository></li><li>FROM <repository>@<digest><ul><li><repository>: 指定作为base image的名称</repository></li><li><tag>: base image的标签，为可选项，可省略</tag></li></ul></digest></repository></li></ul></li><li>MAINTAINER(deprecated)<ul><li>提供本人的详细信息<ul><li>MAINTAINER &lt;author’s detail&gt;</li></ul></li></ul></li><li>LABEL<ul><li>添加一些元数据，可以把作者信息写在LABEL里<ul><li>LABEL <key>=<value></value></key></li></ul></li></ul></li><li>COPY<ul><li>用于从Docker主机复制文件至创建的新镜像文件<ul><li>COPY <src> … <dest></dest></src></li><li>COPY [“<src>“, …, “<dest>“]<ul><li><dest>：建议使用绝对路径，否则将会使用WORKDIR作为起始路径</dest></li></ul></dest></src></li></ul></li><li>文件复制准则<ul><li><src>必须是build上下文中的路径，不能是父路径</src></li><li>如果<src>是目录，则其内部文件或子目录会被递归复制，但<src>目录自身不会被复制</src></src></li><li>如果指定了多个<src>，或在<src>中使用了通配符，则<dest>必须是一个目录，且以/结尾</dest></src></src></li><li>若<dest>不存在，则会被自动创建</dest></li></ul></li></ul></li><li>Dockerfile中一行就是一层</li><li>通过dockerbuild来编译Dockerfile，docker build -t tinyhttpd:v0.2 ./<ul><li>-t，指明编译后的镜像tag</li></ul></li><li>我们可以通过不用-it进入容器中查询，直接执行一个简单的命令改变默认的shell进入<ul><li>docker run –name tinyweb1 –rm tinyhttpd:v0.1 ls /etc/tmp</li></ul></li><li>ADD<ul><li>类似于COPY指令，ADD支持使用TAR和URL路径</li><li>ADD <src> … <dest></dest></src></li><li>ADD [“<src>“, … “<dest>“]</dest></src></li><li>操作准则<ul><li>同COPY指令<ul><li>如果<src>为URL且<dest>不以/结尾，则<src>指定的文件将被下载并直接被创建为<dest></dest></src></dest></src></li><li>若<dest>以/结尾，则被下载并保存为<dest>/<filename></filename></dest></dest></li><li>若<src>是一个本地系统上的压缩格式的tar文件，则会被展开为一个目录，若<src>是个URL上的tar文件，则不会被展开，只会保存</src></src></li></ul></li></ul></li></ul></li><li>WORKDIR<ul><li>用于为Dockerfile指定工作目录，可以指定多个</li><li>WORKDIR &lt;镜像中的目录&gt;</li></ul></li><li>VOLUME<ul><li>用于在image中创建一个挂在点目录</li><li>VOLUME <mountpoint></mountpoint></li><li>VOLUME [“<mountpoint>“]</mountpoint></li><li>如果挂载点目录路径下此前有文件存在，docker run 命令会在卷挂载完毕后将此前的所有文件复制到新挂载的卷中。</li></ul></li><li>EXPOSE<ul><li>用于为容器打开指定要监听的端口以实现与外部通信</li><li>EXPOSE <port>[/<protocol>][<port>[/protocol]…]<ul><li>protocol: tcp/udp 默认tcp</li></ul></port></protocol></port></li><li>可一次指定多个端口：EXPOSE 11211/udp 11211/tcp</li><li>需要注意的是，这个EXPOSE中暴露的端口是可以暴露的端口，但是最重需要docker run -p 来暴露，也可以使用-P来把所有的EXPOSE都暴露</li><li>docker port tinyweb1 查看端口映射</li></ul></li><li><p>ENV</p><ul><li>用于为镜像所需要的环境变量，并可被Dockerfile文件中位于其后的其他指令所调用</li><li>ENV <key> <value></value></key></li><li>ENV <key>=<value>…</value></key></li><li><p>docker run 的时候可以向container传值，但是这样会影响到容器本身的变量<br>￼<img src="https://ws4.sinaimg.cn/large/006tNbRwgy1fwbmmx7yatj30tm08ewgc.jpg" alt=""></p></li><li><p>可以在docker run 启动的时候指定环境变量</p><ul><li>docker run –name tinyweb1 –rm –env WEB_SERVER_PACKAGE=nginx1.15.1 tinyhttpd:v0.7 printenv<br>￼<img src="https://ws3.sinaimg.cn/large/006tNbRwgy1fwbmnll17dj30q8080gmj.jpg" alt=""></li></ul></li></ul></li></ul><p>但并不会影响build，因为run在build后面</p><ul><li>RUN<ul><li>用于指定docker build过程中运行的程序</li><li>发生在build的过程中</li><li>RUN <command></li><li>RUN [“<executable>“, “<param1>“, “<param2>“]<ul><li>但这样子的指令集不是以shell 启动 /bin/sh -c</li><li>所以可以替换成 RUN [“/bin/sh”, “-c”, “<executable>“, “<param1>“]</param1></executable></li></ul></param2></param1></executable></li></ul></li><li>CMD<ul><li>如果没有指定run，默认运行CMD</li><li>发生在run的过程中</li><li>Dockerfile中可以存在多个CMD指令，但仅最后一个会生效</li><li>CMD <command></li><li>CMD [“<executable>“, “<param1>“, “<param2>“]<ul><li>但这样子的指令集不是以shell 启动 /bin/sh -c</li><li>所以可以替换成 CMD [“/bin/sh”, “-c”, “<executable>“, “<param1>“]</param1></executable></li></ul></param2></param1></executable></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天继续输出Docker，等全部看完后，整理成系列。&lt;/p&gt;
&lt;p&gt;为了解决自制镜像问题&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;预定义模版，通过设置不同的变量&lt;br&gt;&lt;img src=&quot;https://ws4.sinaimg.cn/large/006tNbRwgy1fwbmml2vqlj30su0b8q4k.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;￼
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="docker" scheme="http://yoursite.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>淘宝产品十年事读后感</title>
    <link href="http://yoursite.com/%E6%9D%82%E8%B0%88/%E6%B7%98%E5%AE%9D%E4%BA%A7%E5%93%81%E5%8D%81%E5%B9%B4%E4%BA%8B%E8%AF%BB%E5%90%8E%E6%84%9F/"/>
    <id>http://yoursite.com/杂谈/淘宝产品十年事读后感/</id>
    <published>2018-10-16T22:11:40.000Z</published>
    <updated>2018-10-25T22:04:11.208Z</updated>
    
    <content type="html"><![CDATA[<p>「淘宝十年产品事」</p><p>花了6个早上的时间，把这本书看完了，其实中间有2个周末都没有看，还是被事情耽搁了，不如说周末偷懒了。</p><p>这本书前前后后200页，讲述了淘宝从2003年到2013年这十年里发生的变化。从一个产品经理的角度来描述淘宝网的历史变迁，作为一个技术人，看这样子的书往往对自己是比较有帮助的，因为技术人往往把精力过多的集中在技术实现、创新、突破、优化上，而忽略了产品本身的服务对象：人，这也是为什么我会选择看他的原因。可能几年后、或者几个月后、亦或者此时，还有一本「淘宝十年技术事」在酝酿中，谁知道呢。</p><p>整本书并不像苏杰老师的神作「人人都是产品经理」1.0和2.0那般，讲述了很多的产品技巧、产品认知，而是以时间线为维度，按照历史的发展推演淘宝网这10年里主要产品的发展史、遇到的困难、如何通过产品思维来解决它。在本书的最后，也说明了本书例子的局限性。当然了最后一张同样花了大量的篇幅给一些零基础产品经理的建议也是非常有帮助的，只是我觉得和「人人都是产品经理」重叠了，所以就一扫而过了。</p><a id="more"></a><p>本书一共有十章，去头去尾后，还有八章，讲的东西都比较有代表性。第二章的「从“商品”说起」和第三章「淘宝就是导购」讲的就是淘宝网起初作为一个为了打败易趣（中国ebay的前生）而诞生的C2C导购网站，是如何一步步把自己的导购能力武装起来的。看完第二章，再去看看现在的淘宝和ebay，真的感叹ebay被淘汰的铁铮事实<br><img src="https://ws3.sinaimg.cn/large/006tNbRwgy1fwat2r94zoj31kw0tw4ev.jpg" alt=""><br><img src="https://ws4.sinaimg.cn/large/006tNbRwgy1fwat2y6672j31kw15r4ff.jpg" alt=""><br>￼￼<br>淘宝网在导购方面可以说是花足了心思，一级二级三级类目，商品多了上千万了，又衍生出了属性的概念，属性还分子属性、属性值、类目属性等。我比较喜欢其中的一句话：“解决问题，或者说满足需求，通常有三种方法—提高现实，降低期望，转移需求，而常用的开发产品只是第一种，也是最费劲的一种方法。”那么延伸开来讲，第二种我的理解就是用产品化的思维降低原本100分的期望值为80分，从而让用户在80分这个层次感到满足。第三种转移需求无非就是把原本100分的事情搁置在一边，让用户来看看另一个80分的事情，注意这里是另一个80分，不是降维。但提高现实的做法是可以和用户保持长期良性发展的，后两种只能作为紧急应对方法，降低期望做多了会让用户产生抗药性，而转移需求更是把用户往外推了。</p><p>第四章「搜索的启示」对于很多技术人来说，搜索其实一直是个绕不开的问题，怎么把搜索做好从技术角度出发是有很多要说的，但如果遇到卡壳了，不如看看这一章，换个思维角度，用产品思维把这个事情解决了也不尝是一种成功。作为技术，要理解你所做的功能在页面上的位置、作用是非常重要的，而如果知道了现实，在实现上也一定能想到更好的方法。</p><p>第六章「下单之前」、第七章「交易之时」、第八章「付款之后」写的真是精彩。作为技术人，看到了淘宝网作为电商老大在这个领域的考虑，作为产品，从整体角度出发看“支付系统”和“订单系统”是非常用必要的，技术上考虑的是ACID、回滚做好、订单错误处理等，但从产品上看是拍下减库存还是付款减库存进行了一番博弈。最后给出的解决方案是针对不同的市场作出不同的调整，因为这本身就是一个两难的问题，无论哪一个都会遇到大量的矛盾。到底是亲买方还是亲卖方就看淘宝网定位是什么市场了。</p><p>最后，苏杰作为资深产品经理人，给出了自己对于产品经理的模型、练级攻略。作为外行人，看这本书收获还是颇多，需要实践去出真知。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;「淘宝十年产品事」&lt;/p&gt;
&lt;p&gt;花了6个早上的时间，把这本书看完了，其实中间有2个周末都没有看，还是被事情耽搁了，不如说周末偷懒了。&lt;/p&gt;
&lt;p&gt;这本书前前后后200页，讲述了淘宝从2003年到2013年这十年里发生的变化。从一个产品经理的角度来描述淘宝网的历史变迁，作为一个技术人，看这样子的书往往对自己是比较有帮助的，因为技术人往往把精力过多的集中在技术实现、创新、突破、优化上，而忽略了产品本身的服务对象：人，这也是为什么我会选择看他的原因。可能几年后、或者几个月后、亦或者此时，还有一本「淘宝十年技术事」在酝酿中，谁知道呢。&lt;/p&gt;
&lt;p&gt;整本书并不像苏杰老师的神作「人人都是产品经理」1.0和2.0那般，讲述了很多的产品技巧、产品认知，而是以时间线为维度，按照历史的发展推演淘宝网这10年里主要产品的发展史、遇到的困难、如何通过产品思维来解决它。在本书的最后，也说明了本书例子的局限性。当然了最后一张同样花了大量的篇幅给一些零基础产品经理的建议也是非常有帮助的，只是我觉得和「人人都是产品经理」重叠了，所以就一扫而过了。&lt;/p&gt;
    
    </summary>
    
      <category term="杂谈" scheme="http://yoursite.com/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="杂谈" scheme="http://yoursite.com/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>Docker存储卷</title>
    <link href="http://yoursite.com/%E6%8A%80%E6%9C%AF/Docker%E5%AD%98%E5%82%A8%E5%8D%B7/"/>
    <id>http://yoursite.com/技术/Docker存储卷/</id>
    <published>2018-10-16T10:02:11.000Z</published>
    <updated>2018-10-25T22:03:24.181Z</updated>
    
    <content type="html"><![CDATA[<p>Docker-存储卷</p><ul><li>Docker镜像由多个只读层叠加而成，启动容器时，Docker会加载只读镜像层并在镜像栈顶部添加一个读写层</li><li><p>将容器的文件系统和物理机的文件系统绑定关联，容器的数据存储在宿主机的存储目录上，实现数据生命永久<br>￼<img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fwa7zou50oj30qu0iqmz7.jpg" alt=""></p><a id="more"></a></li><li><p>集群文件系统<br>￼<img src="https://ws1.sinaimg.cn/large/006tNbRwgy1fwa819mgtjj30uq0li76u.jpg" alt=""></p></li><li><p>卷为Docker提供了独立于容器的数据管理机制<br>￼<img src="https://ws4.sinaimg.cn/large/006tNbRwgy1fwa81fttovj30xw0f4mzl.jpg" alt=""></p></li><li><p>有两种类型的卷：</p><ul><li>bind mount volume,指定宿主机的路径和docker的路径</li><li>Docker-managed volume，依托docker自主管理<br>￼<img src="https://ws4.sinaimg.cn/large/006tNbRwgy1fwa81kxnu2j30xa0ceac4.jpg" alt=""></li></ul></li><li><p>在容器中使用Volumes</p><ul><li>Docker-managed volume: docker run –name bbox1 –it -v /data/ busybody<br><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fwa81uyysvj30tg098t9v.jpg" alt=""><br>￼<img src="https://ws3.sinaimg.cn/large/006tNbRwgy1fwa81ydvc0j30ok0om771.jpg" alt=""><br><img src="https://ws4.sinaimg.cn/large/006tNbRwgy1fwa820f69qj31js0ggdic.jpg" alt=""><br>￼</li><li>Bind-mount volume: docker run -it -v HOSTDIR:VOLUMEDIR –name bbox2 busybody<ul><li>docker run –name b2 -it –rm -v ~/data/b2:/data busybox<ul><li>需要注意的是，Mac下的共享目录有限制，默认是/Usr, /Volumes, /tmp, /private<br><img src="https://ws1.sinaimg.cn/large/006tNbRwgy1fwa82dhu4xj30tk05w0tg.jpg" alt=""><br>￼<img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fwa82ekarrj30ek056q3a.jpg" alt=""></li></ul></li></ul></li></ul></li><li><p>如果多个容器挂在同一个目录，那么将共享文件</p></li><li>也可以在启动容器的时候指定，我要使用之前的哪个容器的卷<ul><li>–volumes-from b2 ，指定已经存在的容器名</li></ul></li></ul><p>为了让Nginx、Tomcat、MySQL都能够同步在同一个网断下，共享同一个存储卷，还需要指定网络：</p><ul><li>docker run –name infravol –it -v /data/infravol/volumes:/data/web/html busybox</li><li>docker run –name web1 –network container:infravol –volumes-from infravol -it busybox</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Docker-存储卷&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Docker镜像由多个只读层叠加而成，启动容器时，Docker会加载只读镜像层并在镜像栈顶部添加一个读写层&lt;/li&gt;
&lt;li&gt;&lt;p&gt;将容器的文件系统和物理机的文件系统绑定关联，容器的数据存储在宿主机的存储目录上，实现数据生命永久&lt;br&gt;￼&lt;img src=&quot;https://ws2.sinaimg.cn/large/006tNbRwgy1fwa7zou50oj30qu0iqmz7.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="docker" scheme="http://yoursite.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker容器基本操作</title>
    <link href="http://yoursite.com/%E6%8A%80%E6%9C%AF/Docker%E5%AE%B9%E5%99%A8%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
    <id>http://yoursite.com/技术/Docker容器基本操作/</id>
    <published>2018-10-16T09:59:37.000Z</published>
    <updated>2018-10-25T22:03:29.661Z</updated>
    
    <content type="html"><![CDATA[<p>Docker-镜像管理基础</p><h2 id="Docker-Image："><a href="#Docker-Image：" class="headerlink" title="Docker Image："></a>Docker Image：</h2><ul><li>采用分层构建机制，最底层为bootfs，其之为rootfs<ul><li>bootfs：用于系统引导的文件系统，包括bootloader和kernel，容器启动完成后会被卸载以节约内存资源</li><li>rootfs：位于bootfs之上，表现为docker容器的根文件系统</li></ul></li></ul><p><img src="https://ws3.sinaimg.cn/large/006tNbRwgy1fwa7wz17k4j30ou0hiq65.jpg" alt=""><br>￼<br><a id="more"></a></p><p>最底层的是父镜像，最上层的是“可读写”层，其下均为“只读”层<br>挂载方式：联合挂载</p><ul><li>依赖于Aufs，advanced multi-layered unification filesystem，高级多层统一文件系统</li><li>用于为Linux文件系统实现“联合挂载”</li><li>aufs是UnionFS的重新实现</li><li>Ubuntu上使用的是aufs，CentOS7使用的是devicemapper</li></ul><h2 id="Registry"><a href="#Registry" class="headerlink" title="Registry"></a>Registry</h2><ul><li>Repository<ul><li>有特定的docker镜像的所有迭代版本组成的镜像仓库</li><li>一个Resgistry可以存在多个Repository<ul><li>Repository可分为“顶层仓库”和“用户仓库”</li><li>用户仓库名称格式为：用户名/仓库名</li></ul></li><li>每个仓库可以包含多个Tag，每个Tag对应一个镜像</li></ul></li><li>Index<ul><li>维护用户账户，镜像的校验以及公共命名空间</li></ul></li></ul><h2 id="Docker-Hub"><a href="#Docker-Hub" class="headerlink" title="Docker Hub"></a>Docker Hub</h2><ul><li>Image Repository</li><li>Automated Builds</li><li>Webhooks</li><li>Organizations</li><li>Github and Bitbucket Integration</li></ul><p>在Github上写一个DockerFile，DockerHub可以自动监控DockerFile，并创建对应Docker<br>利用Webhooks去关联Github</p><h2 id="docker-pull"><a href="#docker-pull" class="headerlink" title="docker pull"></a>docker pull</h2><p>docker pull quay.io/flannel:0.10.0-amd64</p><h2 id="制作镜像"><a href="#制作镜像" class="headerlink" title="制作镜像"></a>制作镜像</h2><ul><li>Dockerfile</li><li>基于容器制作</li><li>Docker Hub automated builds</li></ul><h3 id="基于容器制作镜像"><a href="#基于容器制作镜像" class="headerlink" title="基于容器制作镜像"></a>基于容器制作镜像</h3><ul><li>进入容器进行修改</li><li>提交新docker的改动：docker commit -p b1, -p pause，暂停container中的状态，b1就是container名字</li><li>给刚刚提交的容器改动打标签：docker tag <container id=""> miracle/httpd:v0.1.0</container></li><li>docker commit -a “Miracle <a href="mailto:&#x6d;&#x69;&#x72;&#x61;&#99;&#108;&#x65;&#64;&#x71;&#x71;&#46;&#99;&#x6f;&#x6d;" target="_blank" rel="noopener">&#x6d;&#x69;&#x72;&#x61;&#99;&#108;&#x65;&#64;&#x71;&#x71;&#46;&#99;&#x6f;&#x6d;</a>“ -c ‘CMD [“/bin/httpd”, “-f”, “-h”, “/data/html/“]’ -p b1 miracleyoung/httpd:v0.1</li><li>docker push miracleYoung/httpd, miracleyoung 必须是账号名</li><li>如果不是推送到DockerHub上去，就要使用：服务器地址/账号名/版本号</li><li>使用阿里云的Docker，按照阿里云给出的Docker路径登陆</li></ul><h2 id="Docker导入导出"><a href="#Docker导入导出" class="headerlink" title="Docker导入导出"></a>Docker导入导出</h2><ul><li>push 上去，pull下来</li><li>把已有镜像压缩打包，然后上传到另一台服务器上<ul><li>docker save -o myimages.gz miracleyoung/httpd:v0.1 busybox:latest</li><li>docker load -I myimages.gz</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Docker-镜像管理基础&lt;/p&gt;
&lt;h2 id=&quot;Docker-Image：&quot;&gt;&lt;a href=&quot;#Docker-Image：&quot; class=&quot;headerlink&quot; title=&quot;Docker Image：&quot;&gt;&lt;/a&gt;Docker Image：&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;采用分层构建机制，最底层为bootfs，其之为rootfs&lt;ul&gt;
&lt;li&gt;bootfs：用于系统引导的文件系统，包括bootloader和kernel，容器启动完成后会被卸载以节约内存资源&lt;/li&gt;
&lt;li&gt;rootfs：位于bootfs之上，表现为docker容器的根文件系统&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://ws3.sinaimg.cn/large/006tNbRwgy1fwa7wz17k4j30ou0hiq65.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;￼&lt;br&gt;
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="docker" scheme="http://yoursite.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker介绍及基本使用</title>
    <link href="http://yoursite.com/%E6%8A%80%E6%9C%AF/Docker%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/技术/Docker介绍及基本使用/</id>
    <published>2018-10-11T15:03:46.000Z</published>
    <updated>2018-10-25T22:03:15.989Z</updated>
    
    <content type="html"><![CDATA[<p>很久没写博客了，真的不好，今天就当是一个新的开始。</p><p>终于有时间可以静下心来完整的看一遍Docker了，之前都是自己瞎玩，感觉差的不是一点两点，今天看了马哥的Docker容器第一章和第二章收获确实颇多。</p><a id="more"></a><h2 id="Docker的概念"><a href="#Docker的概念" class="headerlink" title="Docker的概念"></a>Docker的概念</h2><p>Docker也是一个虚拟化的技术，相较于传统的VirtualMachine，区别是VMs是需要一个完整的操作系统，无论你要运行单一的Nginx又或者是多个MySQL实例，你都需要先安装一个虚拟操作系统，然后在其之上搭建服务。另外，如果你需要多个服务进行隔离，互不干扰，那么就需要使用到隔离技术，隔离技术早就有了，不过这并不是Docker。<br>那么Docker是什么呢？Docker是一个把服务单一化，独立于操作系统的虚拟化技术。举个例子就能理解了：如果我要在Docker里运行Nginx，那么这个Docker里就只跑了一个Nginx，是只有一个Nginx，连PID=1 的那个init都没有，取而代之的是PID=1的Nginx服务。</p><h2 id="Docker的组件"><a href="#Docker的组件" class="headerlink" title="Docker的组件"></a>Docker的组件</h2><p>Docker的组件有很多，不过今天就学了3种：Container（容器）、Image（镜像）、Registry（仓库）。</p><p>什么区别呢？一个个说。</p><p>仓库存储着大量的镜像，每一个镜像都是一个类，而容器就是一个个具体的实例，可以理解为是实例化了。就好像你安装了MySQL，但没有运行MySQL实例，这个时候服务是不存在的，这就是镜像，镜像只是一个静态的东西，需要你去实例化镜像，实例化出来的东西就叫容器。</p><p>仓库里有许多的镜像，例如：Nginx、MySQL等。一个Nginx服务包含很多个版本，相同的版本还有stable、release、alpine等，所以一个仓库下包含着许多的镜像。<br>为了区分他们，命名规则上做出了规范：从仓库中获取一个具体的镜像，需要这么称呼他：<code>nginx:1.14-alpine</code>，这样就能找到唯一的镜像了。</p><h2 id="Docker的基本操作"><a href="#Docker的基本操作" class="headerlink" title="Docker的基本操作"></a>Docker的基本操作</h2><p>Docker发展到现在，已经相当不错了，在命令行里也已经组件化了，我是Mac，所以直接安装的Docker for Mac。安装完后就可以直接使用了。</p><ul><li><code>docker pull nginx:1.14-alpine</code>：从仓库中拉取一个nginx，版本号是1.14-alpine</li><li><code>docker run --name web1 -d nginx:1.14-alpine</code>： -d 参数代表使用daemon的方式启动docker，–name 表示指定该container的名字，最后的nginx:1.14-alpine代表这个容器所使用的镜像名字。<br>我们可以通过 <code>docker container ps</code> 来查看当前docker的运行状况<br><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fw4p8ohd7qj31kw09an0o.jpg" alt="docker container ps"></li><li><code>docker exec -it web1 /bin/sh</code>：exec 表示进入docker container里面去，-it的意思就是交互式操作，web1就是进入到名字叫web1的container里去，最后的/bin/sh 就是以什么样的方式进入，如果你是一个echo，就直接输出了<br><img src="https://ws4.sinaimg.cn/large/006tNbRwgy1fw4pbpiwznj31460i8wgz.jpg" alt="docker exec -it web1 /bin/sh"><br><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fw4p8ohd7qj31kw09an0o.jpg" alt="docker exec -it web1 echo 1"></li></ul><p>但是在这里会有一个坑，也是我希望记录下来的，在Mac中，1024端口以下是需要sudo权限的，而linux没有，所以在视频中，启动了nginx后，是可以在外部使用内网ip:port的方式访问到这个nginx的，而我却不行，之后查阅文档，发现run是有一个端口映射参数的，加上去就好了。<br><code>docker run -p 8080:80 --name web1 -d nginx:1.14-alpine</code>：这里，把container中的80端口映射到我本地的8080端口。</p><p>通过命令<code>docker inspect web1</code> 查看web1容器的详细情况：<br><img src="https://ws1.sinaimg.cn/large/006tNbRwgy1fw4plrxnukj30w40h0myr.jpg" alt="docker inspect web1"><br><img src="https://ws4.sinaimg.cn/large/006tNbRwgy1fw4pltr77aj314s0xatda.jpg" alt="docker inspect web1"></p><p>这样子，就可以本地访问到了。<br><img src="https://ws1.sinaimg.cn/large/006tNbRwgy1fw4plv5oldj30rm10ogq8.jpg" alt="docker run -p 8080:80 --name web1 -d nginx:1.14-alpine"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;很久没写博客了，真的不好，今天就当是一个新的开始。&lt;/p&gt;
&lt;p&gt;终于有时间可以静下心来完整的看一遍Docker了，之前都是自己瞎玩，感觉差的不是一点两点，今天看了马哥的Docker容器第一章和第二章收获确实颇多。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="docker" scheme="http://yoursite.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>平安金融程序员打架</title>
    <link href="http://yoursite.com/%E6%9D%82%E8%B0%88/%E5%B9%B3%E5%AE%89%E9%87%91%E8%9E%8D%E7%A8%8B%E5%BA%8F%E5%91%98%E6%89%93%E6%9E%B6/"/>
    <id>http://yoursite.com/杂谈/平安金融程序员打架/</id>
    <published>2018-08-02T13:53:02.000Z</published>
    <updated>2018-08-02T13:54:04.796Z</updated>
    
    <content type="html"><![CDATA[<p>今天又有一件轰动程序员界的事情发生了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天又有一件轰动程序员界的事情发生了。&lt;/p&gt;

      
    
    </summary>
    
      <category term="杂谈" scheme="http://yoursite.com/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="杂谈" scheme="http://yoursite.com/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>Python枚举类型</title>
    <link href="http://yoursite.com/%E6%8A%80%E6%9C%AF/Python%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B/"/>
    <id>http://yoursite.com/技术/Python枚举类型/</id>
    <published>2018-07-18T15:09:29.000Z</published>
    <updated>2018-10-25T22:03:38.204Z</updated>
    
    <content type="html"><![CDATA[<p>枚举类型可以看作是一种标签或是一系列常量的集合，通常用于表示某些特定的有限集合，例如星期、月份、状态等。</p><p>Python 的原生类型（Built-in types）里并没有专门的枚举类型，但是我们可以通过很多方法来实现它，例如字典、类等：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MiracleLove = &#123;<span class="string">'MON'</span>: <span class="string">'林志玲'</span>, <span class="string">'TUS'</span>: <span class="string">'陈意涵'</span>, <span class="string">'WEN'</span>: <span class="string">'张柏芝'</span>, <span class="string">'THU'</span>: <span class="string">'辛芷蕾'</span>, <span class="string">'FRI'</span>: <span class="string">'周冬雨'</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MiracleLove</span>:</span></span><br><span class="line">   MON = <span class="string">'林志玲'</span></span><br><span class="line">   TUS = <span class="string">'陈意涵'</span></span><br><span class="line">   WEN = <span class="string">'张柏芝'</span></span><br><span class="line">   THU = <span class="string">'辛芷蕾'</span></span><br><span class="line">   FRI = <span class="string">'周冬雨'</span></span><br></pre></td></tr></table></figure></p><p>上面两种方法可以看做是简单的枚举类型的实现。</p><p>如果只在局部范围内用到了这样的枚举变量是没有问题的。</p><p>但问题在于它们都是可变的（mutable），也就是说可以在其它地方被修改从而影响其正常使用：</p><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MiracleLove[<span class="string">'MON'</span>] = MiracleLove[<span class="string">'FRI'</span>]</span><br><span class="line">print(MiracleLove)</span><br></pre></td></tr></table></figure><p>通过类定义的枚举甚至可以实例化，变得不伦不类：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ml = MiracleLove()</span><br><span class="line">print(ml.MON)</span><br><span class="line"></span><br><span class="line">MiracleLove.MON = <span class="number">2</span></span><br><span class="line">print(ml.MON)</span><br></pre></td></tr></table></figure></p><p>当然也可以使用不可变类型（immutable），例如元组，但是这样就失去了枚举类型的本意，将标签退化为无意义的变量：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MiracleLove = (<span class="string">'R'</span>, <span class="string">'G'</span>, <span class="string">'B'</span>)</span><br><span class="line">print(MiracleLove[<span class="number">0</span>], MiracleLove[<span class="number">1</span>], MiracleLove[<span class="number">2</span>])</span><br></pre></td></tr></table></figure></p><p>为了提供更好的解决方案，Python 通过 PEP 435 在 3.4 版本中添加了 enum 标准库，3.4 之前的版本也可以通过 pip install enum 下载兼容支持的库。<br>enum 提供了 Enum/IntEnum/unique 三个工具，用法也非常简单，可以通过继承 Enum/IntEnum 定义枚举类型，其中 IntEnum 限定枚举成员必须为（或可以转化为）整数类型，而 unique 方法可以作为修饰器限定枚举成员的值不可重复：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> enum <span class="keyword">import</span> Enum, IntEnum, unique</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line"><span class="meta">   @unique</span></span><br><span class="line">   <span class="class"><span class="keyword">class</span> <span class="title">MiracleLove</span><span class="params">(Enum)</span>:</span></span><br><span class="line">       MON = <span class="string">'林志玲'</span></span><br><span class="line">       TUS = <span class="string">'陈意涵'</span></span><br><span class="line">       WEN = <span class="string">'张柏芝'</span></span><br><span class="line">       THU = <span class="string">'辛芷蕾'</span></span><br><span class="line">       FRI = <span class="string">'周冬雨'</span></span><br><span class="line"><span class="keyword">except</span> ValueError <span class="keyword">as</span> e:</span><br><span class="line">   print(e)</span><br><span class="line">   </span><br><span class="line"><span class="comment"># duplicate values found in &lt;enum 'MiracleLove'&gt;: FRI -&gt; MON</span></span><br></pre></td></tr></table></figure></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">   <span class="class"><span class="keyword">class</span> <span class="title">MiracleLove</span><span class="params">(IntEnum)</span>:</span></span><br><span class="line">       MON = <span class="number">1</span></span><br><span class="line">       TUS = <span class="number">2</span></span><br><span class="line">       WEN = <span class="number">3</span></span><br><span class="line">       THU = <span class="number">4</span></span><br><span class="line">       FRI = <span class="string">'周冬雨'</span></span><br><span class="line"><span class="keyword">except</span> ValueError <span class="keyword">as</span> e:</span><br><span class="line">   print(e)</span><br><span class="line"></span><br><span class="line"><span class="comment"># invalid literal for int() with base 10: '周冬雨'</span></span><br></pre></td></tr></table></figure><p>更有趣的是 Enum 的成员均为单例（Singleton），并且不可实例化，不可更改：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MiracleLove</span><span class="params">(Enum)</span>:</span></span><br><span class="line">   MON = <span class="string">'林志玲'</span></span><br><span class="line">   TUS = <span class="string">'陈意涵'</span></span><br><span class="line">   WEN = <span class="string">'张柏芝'</span></span><br><span class="line">   THU = <span class="string">'辛芷蕾'</span></span><br><span class="line">   FRI = <span class="string">'周冬雨'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">   MiracleLove.MON = <span class="number">2</span></span><br><span class="line"><span class="keyword">except</span> AttributeError <span class="keyword">as</span> e:</span><br><span class="line">   print(e)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Cannot reassign members.</span></span><br></pre></td></tr></table></figure></p><p>虽然不可实例化，但可以将枚举成员赋值给变量：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mon = MiracleLove(<span class="number">0</span>)</span><br><span class="line">tus = MiracleLove(<span class="number">1</span>)</span><br><span class="line">wen = MiracleLove(<span class="number">2</span>)</span><br><span class="line">print(mon, tus, wen)</span><br><span class="line"></span><br><span class="line"><span class="comment"># MiracleLove.MON </span></span><br><span class="line"><span class="comment"># MiracleLove.TUS </span></span><br><span class="line"><span class="comment"># MiracleLove.WEN</span></span><br></pre></td></tr></table></figure></p><p>也可以进行比较判断：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">print(mon <span class="keyword">is</span> MiracleLove.MON)</span><br><span class="line">print(mon == MiracleLove.MON)</span><br><span class="line">print(mon <span class="keyword">is</span> tus)</span><br><span class="line">print(wen != MiracleLove.TUS)</span><br><span class="line">print(mon == <span class="number">0</span>) <span class="comment"># 不等于任何非本枚举类的值</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># True</span></span><br><span class="line"><span class="comment"># True</span></span><br><span class="line"><span class="comment"># False</span></span><br><span class="line"><span class="comment"># True</span></span><br><span class="line"><span class="comment"># False</span></span><br></pre></td></tr></table></figure></p><p>最后一点，由于枚举成员本身也是枚举类型，因此也可以通过枚举成员找到其它成员：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">print(mon.TUS)</span><br><span class="line">print(mon.TUS.WEN.MON)</span><br><span class="line"></span><br><span class="line"><span class="comment"># MiracleLove.TUS</span></span><br><span class="line"><span class="comment"># MiracleLove.MON</span></span><br></pre></td></tr></table></figure></p><p>但是要谨慎使用这一特性，因为可能与成员原有的命名空间中的名称相冲突：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">print(mon.name, <span class="string">':'</span>, mon.value)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Attr</span><span class="params">(Enum)</span>:</span></span><br><span class="line">   name  = <span class="string">'NAME'</span></span><br><span class="line">   value = <span class="string">'VALUE'</span></span><br><span class="line"></span><br><span class="line">print(Attr.name.value, Attr.value.name)</span><br><span class="line"></span><br><span class="line"><span class="comment"># R : 0</span></span><br><span class="line"><span class="comment"># NAME value</span></span><br></pre></td></tr></table></figure></p><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><hr><p>enum 模块的用法很简单，功能也很明确，但是其实现方式却非常值得学习。如果你想更深入了解更多 Python 中关于 Class 和 Metaclass 的黑魔法，又不知道如何入手，那么不妨阅读一下 enum 的源码。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;枚举类型可以看作是一种标签或是一系列常量的集合，通常用于表示某些特定的有限集合，例如星期、月份、状态等。&lt;/p&gt;
&lt;p&gt;Python 的原生类型（Built-in types）里并没有专门的枚举类型，但是我们可以通过很多方法来实现它，例如字典、类等：&lt;br&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;MiracleLove = &amp;#123;&lt;span class=&quot;string&quot;&gt;&#39;MON&#39;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&#39;林志玲&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;TUS&#39;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&#39;陈意涵&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;WEN&#39;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&#39;张柏芝&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;THU&#39;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&#39;辛芷蕾&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;FRI&#39;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&#39;周冬雨&#39;&lt;/span&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;MiracleLove&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   MON = &lt;span class=&quot;string&quot;&gt;&#39;林志玲&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   TUS = &lt;span class=&quot;string&quot;&gt;&#39;陈意涵&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   WEN = &lt;span class=&quot;string&quot;&gt;&#39;张柏芝&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   THU = &lt;span class=&quot;string&quot;&gt;&#39;辛芷蕾&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   FRI = &lt;span class=&quot;string&quot;&gt;&#39;周冬雨&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;上面两种方法可以看做是简单的枚举类型的实现。&lt;/p&gt;
&lt;p&gt;如果只在局部范围内用到了这样的枚举变量是没有问题的。&lt;/p&gt;
&lt;p&gt;但问题在于它们都是可变的（mutable），也就是说可以在其它地方被修改从而影响其正常使用：&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Bash快捷键</title>
    <link href="http://yoursite.com/%E5%BF%AB%E6%8D%B7%E9%94%AE/Bash%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <id>http://yoursite.com/快捷键/Bash快捷键/</id>
    <published>2018-07-11T14:21:22.000Z</published>
    <updated>2018-07-11T14:22:06.862Z</updated>
    
    <content type="html"><![CDATA[<h2 id="移动光标"><a href="#移动光标" class="headerlink" title="移动光标"></a>移动光标</h2><ul><li>ctrl+b: 前移一个字符(backward)</li><li>ctrl+f: 后移一个字符(forward)</li><li>alt+f: 后移一个单词</li><li>alt+b: 前移一个单词</li><li>ctrl+a: 移到行首（a是首字母）</li><li>ctrl+e: 移到行尾（end）</li><li>ctrl+xx: 行首到当前光标替换</li></ul><a id="more"></a><h2 id="编辑命令"><a href="#编辑命令" class="headerlink" title="编辑命令"></a>编辑命令</h2><ul><li>alt+.: 粘帖最后一次命令最后的参数（通常用于mkdir long-long-dir后, cd配合着alt+.）</li><li>alt+d: 删除当前光标到临近右边单词开始(delete)</li><li>ctrl+w: 删除当前光标到临近左边单词结束(word)</li><li>ctrl+h: 删除光标前一个字符（相当于backspace）</li><li>ctrl+d: 删除光标后一个字符（相当于delete）</li><li>ctrl+u: 删除光标左边所有</li><li>ctrl+k: 删除光标右边所有</li><li>ctrl+l: 清屏</li><li>ctrl+shift+c: 复制（相当于鼠标左键拖拽）</li><li>ctrl+shift+v: 粘贴（相当于鼠标中键）</li></ul><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><ul><li>ctrl+n: 下一条命令</li><li>ctrl+p: 上一条命令</li><li>alt+n: 下一条命令（例如输入ls, 然后按’alt+n’, 就会找到历史记录下的ls命令）</li><li>alt+p: 上一条命令（跟alt+n相似）</li><li>shift+PageUp: 向上翻页</li><li>shift+PageDown: 向下翻页</li><li>ctrl+r: 进入历史查找命令记录， 输入关键字。 多次按返回下一个匹配项</li></ul><h2 id="zsh"><a href="#zsh" class="headerlink" title="zsh"></a>zsh</h2><ul><li>d: 列出以前的打开的命令</li><li>j: jump到以前某个目录，模糊匹配</li></ul><h2 id="Vim"><a href="#Vim" class="headerlink" title="Vim"></a>Vim</h2><h3 id="移动光标-1"><a href="#移动光标-1" class="headerlink" title="移动光标"></a>移动光标</h3><ul><li>b: 向前移动一个单词</li><li>w: 向后移动一个单词<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3></li><li>dw: 从当前光标开始删除到下一个单词头</li><li>de: 从当前光标开始删除到单词尾</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;移动光标&quot;&gt;&lt;a href=&quot;#移动光标&quot; class=&quot;headerlink&quot; title=&quot;移动光标&quot;&gt;&lt;/a&gt;移动光标&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;ctrl+b: 前移一个字符(backward)&lt;/li&gt;
&lt;li&gt;ctrl+f: 后移一个字符(forward)&lt;/li&gt;
&lt;li&gt;alt+f: 后移一个单词&lt;/li&gt;
&lt;li&gt;alt+b: 前移一个单词&lt;/li&gt;
&lt;li&gt;ctrl+a: 移到行首（a是首字母）&lt;/li&gt;
&lt;li&gt;ctrl+e: 移到行尾（end）&lt;/li&gt;
&lt;li&gt;ctrl+xx: 行首到当前光标替换&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="快捷键" scheme="http://yoursite.com/categories/%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    
    
      <category term="快捷键" scheme="http://yoursite.com/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    
  </entry>
  
  <entry>
    <title>2018上半年复盘</title>
    <link href="http://yoursite.com/Diary/2018%E4%B8%8A%E5%8D%8A%E5%B9%B4%E5%A4%8D%E7%9B%98/"/>
    <id>http://yoursite.com/Diary/2018上半年复盘/</id>
    <published>2018-07-08T00:29:21.000Z</published>
    <updated>2018-07-08T00:30:15.360Z</updated>
    
    <content type="html"><![CDATA[<p>2018年上半年已经过去整整6个月了。是应该做一次完整清晰的复盘了。</p><a id="more"></a><ol><li><p>2018年1月始，我开始了 <code>MiracleOps</code> 的研发。（感兴趣的小伙伴可以去github上搜：<a href="https://github.com/MiracleYoung/MiracleOps）" target="_blank" rel="noopener">https://github.com/MiracleYoung/MiracleOps）</a><br>因为自己是做DevOps这块的，而之前的工作中有独立开发过一套运维平台，但是那个现在想来真的不算什么。就是一个纯后台sql查询出来结果，用于前段ECharts的展示。<br>所以在决定开始做这个的时候，是下了很大的决心的，希望通过这个平台，能够让自己的能力有所提升，让自己对运维体系有更深刻的理解，也希望能够帮助到中小企业在解决DevOps的路上走的更稳。<br>工程之初一定是要来一个思维导图的（该图也一并在项目首页上），在做思维导图的时候可以对整个项目有一个非常清晰的milestone。<br>譬如，先做什么模块，在做什么模块；做 <code>CMDB</code> 的时候采用 <code>Ansible</code> 还是 <code>SaltStack</code> ；要实现 <code>Web Terminal</code> 应该采用什么技术栈等等。<br>我记得做这个Map就做了好几天，需要对每一个既有的模块做调研，并实际POC一下，切实可行并符合我的需求。这个过程其实蛮享受的，能够在短时间内窥视很多新的技术。<br>之后我每天早上和晚上基本都在写这个 <code>MiracleOps</code> 。一周出一个Release。<br>不过由于其他原因，没能坚持下来，做了大概3个月，实现了 <code>CMDB</code>, <code>Cluster Management</code>, <code>Web Terminal</code> 后就没再去维护了。准备下半年能对这个平台进行重构，并继续扩展。</p></li><li><p>结交了很多同行，还获得了许多的支持。<br>平时业余时间喜欢接触行业同仁，所以有机会也会经常参加一些社区活动。期间认识了不少行业中非常顶尖的专家、老板。学到了很多。<br>大牛不会在乎你的学历，只要你是认真的在做事，认真的在提问，他们都是非常乐意解答的。<br>真正的合作伙伴是共赢而非互相抵制。这个就不得不说道前几天看到的新闻：「一瓜农一夜间2万个西瓜都被砍了」。这不是行业竞争是什么？在农村，很多见不得人发的，都会采用这种方式，类似鱼塘撒药、田地放虫等等。<br>和共赢的小伙伴一起做事很开心，享受过程，彼此是互相帮助着解决眼前的问题，达到了成就彼此分享、复盘。<br>非常感谢「mongoDB社区的主席TJ及社区的小伙伴」、「马哥的联合创始人张sir及老师们」、「海量数据学院的崔老师及合作过的老师」等等，太多了，无法一一点名，抱歉。</p></li><li><p>五一开创公众号「猿媛牧场」，并于6月28日更名为「Python专栏」。<br>当时的想法就是，「别人靠公众号赚钱了，我也要赚钱」就做了。做了一个月就发现「钱不是那么好赚的」。<br>慢慢的，我开始改变了我的初衷，「钱可以慢慢赚，事儿得认真做！」。<br>就这样，我开始潜心研究许多大号的文章，记录他们的排版，从内容深度和广度上思考于我有益的地方。譬如，关注我公众号的小伙伴应该可以发现，最近头部那里开始有插画了，这个排版就是和自媒体大号咪蒙学的。<br>这几天我会在星球里发布一个成长计划，关于如何运作，如何做好星球的计划。<br>做了2个多月了，踩了不少的坑，也学到了很多。最重要的还是复盘，每周的复盘都会发现一周里可以改的地方有很多，可以调整的余地还有很多。<br>感谢公众号里的各位大佬对我孜孜不倦的教导，让我能够坚持这条路。</p></li></ol><p>总结上半年：</p><ol><li><code>MiracleOps</code> 维护3个月</li><li>认识了很多大牛、老板</li><li>开创了公众号「Python专栏」</li></ol><p>下半年展望：</p><ol><li>重启 <code>MiracleOps</code></li><li>公众号粉丝从3500做到10000</li><li>每天都有输入，学习技术、写作、运营。</li><li>多些时间陪伴家人。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2018年上半年已经过去整整6个月了。是应该做一次完整清晰的复盘了。&lt;/p&gt;
    
    </summary>
    
      <category term="Diary" scheme="http://yoursite.com/categories/Diary/"/>
    
    
      <category term="Dairy" scheme="http://yoursite.com/tags/Dairy/"/>
    
  </entry>
  
  <entry>
    <title>Dairy 20180705</title>
    <link href="http://yoursite.com/Diary/20180705/"/>
    <id>http://yoursite.com/Diary/20180705/</id>
    <published>2018-07-05T14:30:17.000Z</published>
    <updated>2018-07-05T15:11:20.847Z</updated>
    
    <content type="html"><![CDATA[<ul><li>初识Spark</li><li>公众号运营</li></ul><a id="more"></a><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>终于搞定GithubPages，采用yilia主题，查找文档，github api 文档，完成个人博客迁移！</p><ul><li>yilia的config文件定义github oauth的地方需要注意<ul><li><code>gitment_owner</code> 这里填的是你的用户名，比如我的是<code>miracleyoung</code>，就是github仓库的前缀</li><li><code>gitment_repo</code> 填的也不是完整url，就是你的仓库，比如我的是<code>miracleyoung.github.io</code></li><li>其他看yilia文档就都ok</li></ul></li></ul><p>感觉有好多东西要做，记了个list，觉得还是蛮有用的，起码知道自己还要看什么。</p><p>然后就是利用mac的日记了，真的蛮好，从今天往后，准备每周日规划下一周的工作和学习安排。</p><p>我是个生物钟在白天而不是晚上的人，所以准备在早上学习，把工作放在下午。</p><p>除了工作和学习外，要学会合理安排空余时间</p><ul><li>公众号</li><li>写代码<ul><li>MagCore 客户端</li><li>WX_QQ_Robot</li></ul></li><li>陪家人</li></ul><p>感觉每天只要学习完了，后面的事情都不是重点了。。。好像也不是，还有晚上的时间也蛮重要的。</p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;初识Spark&lt;/li&gt;
&lt;li&gt;公众号运营&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Diary" scheme="http://yoursite.com/categories/Diary/"/>
    
    
      <category term="Dairy" scheme="http://yoursite.com/tags/Dairy/"/>
    
  </entry>
  
  <entry>
    <title>Dairy 20180701</title>
    <link href="http://yoursite.com/Diary/20180701/"/>
    <id>http://yoursite.com/Diary/20180701/</id>
    <published>2018-07-01T00:06:22.746Z</published>
    <updated>2018-07-05T15:05:39.505Z</updated>
    
    <content type="html"><![CDATA[<h2 id="复盘20180625-20180630"><a href="#复盘20180625-20180630" class="headerlink" title="复盘20180625-20180630"></a>复盘20180625-20180630</h2><ul><li>看完Python Data Structure</li><li>初探ELK</li><li>Tapdata POC 文档</li><li>向张sir 讨教了公众号运营心得</li></ul><a id="more"></a><h2 id="Tech"><a href="#Tech" class="headerlink" title="Tech"></a>Tech</h2><h3 id="Python-Data-Structure"><a href="#Python-Data-Structure" class="headerlink" title="Python Data Structure"></a>Python Data Structure</h3><ul><li>查找的方法<ul><li>顺序查找</li><li>二分查找 =&gt; 依赖有序列表</li><li>hash查找 =&gt; 拉链发/开地址法</li></ul></li><li>排序<ul><li>冒泡排序</li><li>选择排序</li><li>插入排序</li><li>希尔排序</li><li>归并排序</li><li>快速排序</li></ul></li></ul><h3 id="初探ELK"><a href="#初探ELK" class="headerlink" title="初探ELK"></a>初探ELK</h3><ul><li>掌握了Elasticsearch/Logstash/Kibana的基本用法</li><li>搭建ELK</li><li>可以通过Logstash的自定义pattern对mongoDB的log日志进行解析。</li><li>目前还需要对mongodb的日志进行进一步解析，以获得有用数据</li><li>掌握了Logstash的grok用法</li></ul><h3 id="Tapdata-Poc-文档"><a href="#Tapdata-Poc-文档" class="headerlink" title="Tapdata Poc 文档"></a>Tapdata Poc 文档</h3><ul><li>完成对AWR报告的分析</li><li>制定POC方案</li></ul><h3 id="向张sir-讨教了公众号运营心得"><a href="#向张sir-讨教了公众号运营心得" class="headerlink" title="向张sir 讨教了公众号运营心得"></a>向张sir 讨教了公众号运营心得</h3><ul><li>目前阶段，可以通过 互推/踩热点 来引流</li><li>踩热点要能够抓住关键词</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;复盘20180625-20180630&quot;&gt;&lt;a href=&quot;#复盘20180625-20180630&quot; class=&quot;headerlink&quot; title=&quot;复盘20180625-20180630&quot;&gt;&lt;/a&gt;复盘20180625-20180630&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;看完Python Data Structure&lt;/li&gt;
&lt;li&gt;初探ELK&lt;/li&gt;
&lt;li&gt;Tapdata POC 文档&lt;/li&gt;
&lt;li&gt;向张sir 讨教了公众号运营心得&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Diary" scheme="http://yoursite.com/categories/Diary/"/>
    
    
      <category term="Dairy" scheme="http://yoursite.com/tags/Dairy/"/>
    
  </entry>
  
  <entry>
    <title>Dairy 20180628</title>
    <link href="http://yoursite.com/Diary/20180628/"/>
    <id>http://yoursite.com/Diary/20180628/</id>
    <published>2018-06-29T14:36:00.298Z</published>
    <updated>2018-07-05T15:05:35.135Z</updated>
    
    <content type="html"><![CDATA[<ul><li>Elasticsearch</li><li>Logstash</li></ul><a id="more"></a><h2 id="Tech"><a href="#Tech" class="headerlink" title="Tech"></a>Tech</h2><h3 id="Elasticsearch"><a href="#Elasticsearch" class="headerlink" title="Elasticsearch"></a>Elasticsearch</h3><ul><li>索引，indices</li><li>index =&gt; db, type =&gt; table, document =&gt; row</li><li><code>/_cat</code> 查看一些系统命令</li><li><code>/_search</code> 查找</li></ul><h3 id="Logstash"><a href="#Logstash" class="headerlink" title="Logstash"></a>Logstash</h3><ul><li>input{}, filter{}, output{}</li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">    file &#123;</span><br><span class="line">        path =&gt; [&apos;&apos;, &apos;&apos;]</span><br><span class="line">        type =&gt; &quot;system&quot;</span><br><span class="line">        start_position =&gt; &quot;beginning&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>plugin</p><ul><li>generator plugin: 生成加数据</li></ul></li><li>Redis 可以作为Broker</li><li>collectd：收集系统性能和提供各种存储方式来存储不同值的机制</li><li><p>Grok</p><ul><li><code>%{SYNTAX_NAME:SEMANTIC}</code>, %{表达式名字：解析出来的名字}</li><li>pattern 在 <code>vendor/bundle/jruby/2.3.0/gems/logstash-pattern-core-4.1.2/patterns</code> 下面</li><li><p>自定义pattern</p><ul><li>匿名：将 <code>%{SYNTAX_NAME:SEMANTIC}</code> =&gt; <code>(?&lt;SEMANTIC&gt;regexp)</code></li><li><p>非匿名</p><ul><li>在pattern目录下创建一个文件，文件名随意</li><li><p>将dir 加入grok路径，</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">grok &#123;</span><br><span class="line">    patterns_dir =&gt; &quot;./dir&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>文件内：<code>SYNTAX_NAME regexp</code></p></li><li>使用方法相同 <code>%{SYNTAX_NAME:SEMANTIC}</code></li></ul></li></ul></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;Elasticsearch&lt;/li&gt;
&lt;li&gt;Logstash&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Diary" scheme="http://yoursite.com/categories/Diary/"/>
    
    
      <category term="Dairy" scheme="http://yoursite.com/tags/Dairy/"/>
    
  </entry>
  
  <entry>
    <title>Dairy 20180624</title>
    <link href="http://yoursite.com/Diary/20180624/"/>
    <id>http://yoursite.com/Diary/20180624/</id>
    <published>2018-06-26T13:11:47.486Z</published>
    <updated>2018-07-05T15:05:31.377Z</updated>
    
    <content type="html"><![CDATA[<ul><li>查找<ul><li>顺序查找</li><li>二分查找</li><li>Hash查找<ul><li>分组求合法</li><li>平方取中法</li></ul></li></ul></li><li>排序<ul><li>冒泡排序</li><li>选择排序</li><li>插入排序</li><li>希尔排序</li><li>归并排序</li><li>快速排序</li></ul></li></ul><a id="more"></a><h2 id="Tech"><a href="#Tech" class="headerlink" title="Tech"></a>Tech</h2><h3 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h3><ul><li>无序列表和有序列表都是 O(n)</li></ul><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><ul><li>有序列表对于二分查找非常重要</li><li>选择中间的数进行比较，然后缩小范围，在选择中间数进行比较</li><li>O(log^n)</li></ul><h3 id="Hash查找"><a href="#Hash查找" class="headerlink" title="Hash查找"></a>Hash查找</h3><ul><li>开地址法和拉链法</li></ul><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><ul><li>将列表从头开始遍历，每次遍历都将最大的值放在正确的地方（比如列表的尾部）</li><li>一共要循环n-1次，所以复杂度是 O(n^2)</li><li>若遍历期间没有交换，则说明已经排序，若已经排序，则可以提前停止。这种叫 <strong>短冒泡排序</strong></li></ul><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><ul><li>每次遍历记录下最大的项，只做一次交换</li><li>虽然也是O(n^2) 但是交换次数明显减少很多</li></ul><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><ul><li>维护一个子列表, 每次遍历都将新值插入到合适的位置</li><li>新值和列表中的末尾进行比较，若末尾大，则后移一位，继续比较。直到遇到小于他的数字，则停止移位，并停留在空白处。</li></ul><p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fsows5uu7sj30jd09u0tm.jpg" alt=""></p><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><ul><li>递减递增排序</li><li>将原始列表拆分为多个子列表</li><li>每个子列表采用插入排序</li><li>选取合适的增量GAP来决定子列表</li></ul><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><ul><li><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fsowxw60wzj30kh09wwf7.jpg" alt=""></li><li>不断将列表拆分为一半，若列表为空或一半，则按定义进行排序</li><li>一旦对两半列表排序完成，则进行合并</li></ul><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><ul><li><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fsox3fzgpdj30jh0jwgnc.jpg" alt=""></li><li>选择一个枢轴值，帮助拆分列表。一般选择第一个。</li><li>从左开始直到大于枢轴值，从右开始直到小于枢轴值，交换2个值，继续。</li><li>若枢轴值在中间，则只需要O(log^n)，为了找到分割点，需要检查n个项，所以是O(nlog^n)，如果非常偏向左或右，就是O(n)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;查找&lt;ul&gt;
&lt;li&gt;顺序查找&lt;/li&gt;
&lt;li&gt;二分查找&lt;/li&gt;
&lt;li&gt;Hash查找&lt;ul&gt;
&lt;li&gt;分组求合法&lt;/li&gt;
&lt;li&gt;平方取中法&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;排序&lt;ul&gt;
&lt;li&gt;冒泡排序&lt;/li&gt;
&lt;li&gt;选择排序&lt;/li&gt;
&lt;li&gt;插入排序&lt;/li&gt;
&lt;li&gt;希尔排序&lt;/li&gt;
&lt;li&gt;归并排序&lt;/li&gt;
&lt;li&gt;快速排序&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Diary" scheme="http://yoursite.com/categories/Diary/"/>
    
    
      <category term="Dairy" scheme="http://yoursite.com/tags/Dairy/"/>
    
  </entry>
  
  <entry>
    <title>Dairy 20180617</title>
    <link href="http://yoursite.com/Diary/20180617/"/>
    <id>http://yoursite.com/Diary/20180617/</id>
    <published>2018-06-17T23:01:38.849Z</published>
    <updated>2018-07-05T15:05:26.074Z</updated>
    
    <content type="html"><![CDATA[<ul><li>学习《Python Data Structure》4.1-4.10。掌握了递归的基本用法。</li><li>早上对媳妇有点不满，不太好，心胸开阔一些，与人为善一点。</li></ul><a id="more"></a><h2 id="Tech"><a href="#Tech" class="headerlink" title="Tech"></a>Tech</h2><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><ul><li>计算整数列表和</li><li>阿西莫夫机器人。及在递归中的表现。<ul><li>递归算法必须是有基本情况 =&gt; 退出条件</li><li>递归算法必须改变其状态，并向基本情况靠近 =&gt; 数据在变小</li><li>递归算法必须以递归方式调用自身</li></ul></li></ul><h3 id="数据转换字符串"><a href="#数据转换字符串" class="headerlink" title="数据转换字符串"></a>数据转换字符串</h3><ul><li>在python中，任意2-16进制数 <strong>整除</strong> 一个数后，都会转成 <strong>十进制数</strong></li></ul><h3 id="栈针"><a href="#栈针" class="headerlink" title="栈针"></a>栈针</h3><ul><li>使用栈来存储余数，然后在pop出来</li></ul><h3 id="可视化递归"><a href="#可视化递归" class="headerlink" title="可视化递归"></a>可视化递归</h3><ul><li>turtle<ul><li>初始化方向向右</li><li>up(), 抬笔</li><li>down(), 落笔</li></ul></li><li>自相似性：无论放大多少倍，都是一样的。例如：树和树枝，树枝可以看成树的缩小版</li></ul><h3 id="谢尔宾斯基三角形"><a href="#谢尔宾斯基三角形" class="headerlink" title="谢尔宾斯基三角形"></a>谢尔宾斯基三角形</h3><ul><li>三角形，取其中一顶点以及该顶点与另外2点连线的中点组成的小三角形，以此可以无限循环</li></ul><h3 id="汉诺塔游戏"><a href="#汉诺塔游戏" class="headerlink" title="汉诺塔游戏"></a>汉诺塔游戏</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tower</span><span class="params">(height, from, to, with)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> height &gt;= <span class="number">1</span>:</span><br><span class="line">        tower(height - <span class="number">1</span>, <span class="keyword">from</span> , <span class="keyword">with</span>, to)</span><br><span class="line">        move_disk(<span class="keyword">from</span>, to)</span><br><span class="line">        tower(height - <span class="number">1</span>, <span class="keyword">from</span> , to, <span class="keyword">with</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;学习《Python Data Structure》4.1-4.10。掌握了递归的基本用法。&lt;/li&gt;
&lt;li&gt;早上对媳妇有点不满，不太好，心胸开阔一些，与人为善一点。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Diary" scheme="http://yoursite.com/categories/Diary/"/>
    
    
      <category term="Dairy" scheme="http://yoursite.com/tags/Dairy/"/>
    
  </entry>
  
  <entry>
    <title>Dairy 20180615</title>
    <link href="http://yoursite.com/Diary/20180615/"/>
    <id>http://yoursite.com/Diary/20180615/</id>
    <published>2018-06-17T06:20:10.327Z</published>
    <updated>2018-07-05T15:05:21.250Z</updated>
    
    <content type="html"><![CDATA[<ul><li>学习《Python Data Structure》3.10 - 3.24</li></ul><a id="more"></a><h2 id="Tech"><a href="#Tech" class="headerlink" title="Tech"></a>Tech</h2><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><ul><li>FIFO，先进先出的有序集合</li><li>添加项的一端是队尾，删除项的一端是队首</li><li><code>Queue()</code><ul><li><code>enqueue()</code></li><li><code>dequeue()</code></li><li><code>size()</code></li><li><code>is_empty()</code></li></ul></li><li>约瑟夫问题，有n个人，按m报数，第m个人自杀，直到最后一个</li></ul><h3 id="打印机队列"><a href="#打印机队列" class="headerlink" title="打印机队列"></a>打印机队列</h3><ul><li>有1台打印机每分钟打印k张纸，n个学生每个学生创建任务页数1-20页</li><li>打印机的任务队列，每个任务都有时间戳（用于标记任务创建的时间，最后用于计算任务开始的时候离创建的时候花费了多久）</li><li>每秒：<ul><li>是否创建新的打印任务（通过一个随机函数来判断），若是，将任务添加到任务队列中</li><li>若打印机不忙，并且有任务在队列中<ul><li>从打印机队列中删除一个任务，并将其分配给打印机</li><li>从当前时间减去创建时间，获得当前任务的等待时间</li><li>将等待时间添加到时间等待列表中，一共后续计算</li><li>根据打印任务的页数，计算打印机打印完这个任务需要多少时间</li></ul></li><li>打印机需要1秒打印，需要从等待时间中减去一秒</li><li>若任务完成，所需时间已经达到零，打印机空闲</li></ul></li><li>模拟完成后，从生成的等待时间列表中计算平均等待时间。</li></ul><h3 id="Deque"><a href="#Deque" class="headerlink" title="Deque"></a>Deque</h3><ul><li>双向队列</li><li><code>Deque()</code><ul><li><code>add_front(item)</code></li><li><code>add_rear(item)</code></li><li><code>remove_front()</code></li><li><code>remove_rear()</code></li><li><code>is_empty()</code></li><li><code>size()</code></li></ul></li></ul><h3 id="回文检查"><a href="#回文检查" class="headerlink" title="回文检查"></a>回文检查</h3><ul><li>头尾相同的字符串，例如：rtotr, abba</li><li>用deque来做，存的时候<code>add_front()</code>, 取的时候<code>remove_front()</code>,<code>remove_rear()</code> 比较即可</li></ul><h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><ul><li><code>List()</code><ul><li><code>add(item)</code></li><li><code>remove(item)</code></li><li><code>search(item)</code></li><li><code>is_empty()</code></li><li><code>size()</code></li><li><code>append(item)</code></li><li><code>index(item)</code></li><li><code>insert(pos, item)</code></li><li><code>pop()</code></li><li><code>pop(pos)</code></li></ul></li></ul><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><ul><li>没有next节点的节点称为“接地节点”</li></ul><h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><ul><li><code>OrderList()</code></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;学习《Python Data Structure》3.10 - 3.24&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Diary" scheme="http://yoursite.com/categories/Diary/"/>
    
    
      <category term="Dairy" scheme="http://yoursite.com/tags/Dairy/"/>
    
  </entry>
  
  <entry>
    <title>Dairy 20180614</title>
    <link href="http://yoursite.com/Diary/20180614/"/>
    <id>http://yoursite.com/Diary/20180614/</id>
    <published>2018-06-14T22:03:36.401Z</published>
    <updated>2018-07-05T15:05:14.978Z</updated>
    
    <content type="html"><![CDATA[<ul><li>学习了《Python Data Structure》的 3.1～3.9</li><li>和青软初步定了8月8号～8月12号的 5天 Python 内训</li><li>装了电风扇</li><li>写公众号</li><li><strong>总结没有写，时间不够，因为看了电视剧</strong></li></ul><a id="more"></a><h2 id="Tech"><a href="#Tech" class="headerlink" title="Tech"></a>Tech</h2><ul><li>掌握了栈的定义、基本应用、使用python构造栈</li></ul><h3 id="线性结构"><a href="#线性结构" class="headerlink" title="线性结构"></a>线性结构</h3><ul><li>数据项之间的顺序由增加或删除的顺序决定的数据结构，称线性数据结构</li></ul><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><ul><li>先进后出，LIFO</li><li>添加或删除项都发生在顶部，入口即出口</li><li>栈的作用：能反转项的顺序（浏览网页时候的后退）</li><li>使用python，实现了自定义的Stack，具有如下几个方法<ul><li><code>is_empty()</code></li><li><code>push()</code></li><li><code>pop()</code></li><li><code>peek()</code></li><li><code>size()</code></li></ul></li></ul><h4 id="用栈对括号匹配进行检查"><a href="#用栈对括号匹配进行检查" class="headerlink" title="用栈对括号匹配进行检查"></a>用栈对括号匹配进行检查</h4><ul><li>栈里存 “(“，遇到 “)” 就 <code>Stack.pop()</code></li><li>如果当前符号是 “)” ，且 <code>Stack.is_empty()</code>，则不匹配，即可退出</li><li>若最后存在标志位为True，且栈为空，则括号匹配检查成功</li><li>复杂括号匹配，使用 <code>&quot;([{&quot;.index(&quot;(&quot;)</code> 的方法对当前符号进行检查，</li></ul><h4 id="十进制转二进制"><a href="#十进制转二进制" class="headerlink" title="十进制转二进制"></a>十进制转二进制</h4><ul><li>十进制转二进制采用“除2取余法”，由于最后的余数是二进制最左边的那个数，所以可以使用栈。</li><li>数字^10 % 2 结果push 到 Stack 中去</li><li><code>&#39;&#39;.join(Stack.pop())</code></li><li>如果将十进制换成任意进制的数字，则添加一个digits参照表：<code>digits = &#39;0123456789ABCDEF&#39;</code>，每次 pop 出来的数字采用<code>digits[Stack.pop()]</code> 进行转换</li></ul><h4 id="中缀（Infix）-前缀（Prefix）-后缀（Postfix）"><a href="#中缀（Infix）-前缀（Prefix）-后缀（Postfix）" class="headerlink" title="中缀（Infix）/前缀（Prefix）/后缀（Postfix）"></a>中缀（Infix）/前缀（Prefix）/后缀（Postfix）</h4><ul><li>掌握中缀/前缀/后缀表达式的定义及转换<ul><li>中缀：A + B * C <ul><li>前缀：+A*BC</li><li>后缀：ABC*+</li></ul></li></ul></li><li>中缀转后缀<ul><li>把字符串split成列表，初始化一个Stack</li><li>通过一个优先级字典 <code>priority = {&#39;*&#39;: 3, &#39;/&#39;: 3, &#39;+&#39;: 2, &#39;-&#39;: 2, &#39;(&#39;: 1}</code>，来判断字符和操作符的入栈顺序</li><li>若”(“，则直接入栈</li><li>若”)”，循环 <code>Stack.pop()</code>，出来的不是 “(“，就追加到结果中去，否则退出循环</li><li>若”*/+-“，若Stack不为空，且Stack.peek() &gt;= 当前操作符的优先级，则append到结果中去，再把当前操作符push到Stack中，否则直接push到Stack中</li><li>循环结束后，若Stack不为空，则循环pop，并append到结果中</li><li><code>&#39;&#39;.join(ret)</code></li></ul></li><li>计算后缀<ul><li>若是[0-9]，则push到Stack中去</li><li>若是操作符，则从Stack中pop出2个，与操作符进行计算，<strong>计算顺序为第二个pop出来的数字 操作符 第一个pop出来的数字</strong></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;学习了《Python Data Structure》的 3.1～3.9&lt;/li&gt;
&lt;li&gt;和青软初步定了8月8号～8月12号的 5天 Python 内训&lt;/li&gt;
&lt;li&gt;装了电风扇&lt;/li&gt;
&lt;li&gt;写公众号&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;总结没有写，时间不够，因为看了电视剧&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Diary" scheme="http://yoursite.com/categories/Diary/"/>
    
    
      <category term="Dairy" scheme="http://yoursite.com/tags/Dairy/"/>
    
  </entry>
  
  <entry>
    <title>Dairy 20180606</title>
    <link href="http://yoursite.com/Diary/20180606/"/>
    <id>http://yoursite.com/Diary/20180606/</id>
    <published>2018-06-06T14:38:08.873Z</published>
    <updated>2018-07-05T15:05:05.277Z</updated>
    
    <content type="html"><![CDATA[<ul><li>上午看了PEP8规范、一些python的文章</li><li>下午继续看python的文章，对于super继承有了新的认识，对于反射器理解的还不是很透彻，明天继续</li></ul><a id="more"></a><h2 id="Tech"><a href="#Tech" class="headerlink" title="Tech"></a>Tech</h2><h3 id="代码技巧"><a href="#代码技巧" class="headerlink" title="代码技巧"></a>代码技巧</h3><ul><li>提前结束代码，比如使用raise关键字去将几个and条件拆开来</li><li>函数可以有效封装</li><li>动态表达式：<code>f = func1 or func2; f(*args)</code>，利用参数解构</li><li>利用 <strong>德摩根定律</strong>， (A交B)的反 = (A的反)并(B的反)</li><li>通过对类<code>__len__</code>的自定义，来满足类的bool比较</li><li><p>多使用<code>all()</code>和<code>any()</code></p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fn</span><span class="params">(numbers)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> bool(numbers) <span class="keyword">and</span> all(n &gt; <span class="number">10</span> <span class="keyword">for</span> n <span class="keyword">in</span> numbers)</span><br></pre></td></tr></table></figure></li><li><p>多使用<code>try...else</code>和<code>for...else</code></p></li></ul><h3 id="陷阱"><a href="#陷阱" class="headerlink" title="陷阱"></a>陷阱</h3><ul><li>使用<code>is None</code>而不是<code>== None</code></li><li>and的优先级大于or：<code>True or False and False</code>和<code>(True or False) and False</code></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;上午看了PEP8规范、一些python的文章&lt;/li&gt;
&lt;li&gt;下午继续看python的文章，对于super继承有了新的认识，对于反射器理解的还不是很透彻，明天继续&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Diary" scheme="http://yoursite.com/categories/Diary/"/>
    
    
      <category term="Dairy" scheme="http://yoursite.com/tags/Dairy/"/>
    
  </entry>
  
</feed>
